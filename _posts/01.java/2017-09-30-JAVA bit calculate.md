---
layout: post
title: "JAVA基础——字节&位运算"
date: 2017-09-30
categories: JAVA
tags: JAVA 位运算
---

* content
{:toc}

对JAVA中基本类型字节长度，源码、反码、补码计算，位移运算等回顾总结记录下。




## 占用字节数 & 取值范围

Java一共有8种基本数据类型（原始数据类型）：  
```
    类型            存储要求               范围（包含）                默认值              包装类
    int           4字节（32位）          -2^31~ 2^31-1                  0               Integer
    short         2字节（16位）          -215~215-1                     0               Short
    long          8字节（64位）          -2^63~2^63-1                   0               Long
    byte          1字节（8位）           -2^7~2^7-1                     0               Byte
    float         4字节（32位）          -3.4e+38 ~ 3.4e+38            0.0f             Float
    double        8字节（64位）          -1.7e+308 ~ 1.7e+308           0               Double
    char          2字节（16位）          u0000~uFFFF（‘’~‘？’）         ‘0’              Character 
    boolean       1/8字节(1位）          true, false                  FALSE             Boolean
```

对于float与double类型：

内存结构：

> 1. float类型： 内存中共占4个字节，32bit位，其中bit位从高到低，依次是1位符号位、8位指数位、23位尾数位；
> 2. double类型：内存中共占8字节，64bit位，其中bit位从高到低，依次是1位符号位、11位指数位、52位尾数位；

精度：
精度由尾数的位数决定，在内存中按照科学计数法的方式存储的。

关于比较是否相等：
> 1. 两个浮点数之间不能通过==来比较是否相等，因为浮点数的精度是有限制的，超过精度限制的浮点数，计算机会将精度之外的小数部分截断，如果直接==比较的话，会出现两个不一样的值结果大小判断却相等的情况。
> 2. 一般情况下，不要通过==或者!=来比较，可以通过判断其差值的绝对值是否大于0来判断。
> 3. 实际应用中，一般两个浮点数之间的差值的绝对值小于等于某一个可接受的误差（即：精度，比如0.00000001），就认为是相同的。

实际应用原则：
> 1. 程序中尽量避免浮点型数据的比较；
> 2. float、double类型运算一般都不准确，只适合科学计算或者工程计算，不适用与商业计算。比如1.0f-0.9f=0.100000024


为了解决JAVA中浮点数精度不够的问题，可以使用BigDecimal来替代，适用于对精度要求较高的系统中。


## 源码 & 反码 && 补码
### 源码

源码就是数字对应的二进制表示。

**负数的源码 = 正数的源码取反再加1**

### 反码
正数的反码就是源码自身。

负数的反码就是：保持源码符号位不变，其余各个位取反。

### 补码

正数的补码就是源码自身。

负数的补码就是： 反码基础上加1

如何根据补码计算源码：

> 1. 最高位如果是0，即为正数，其补码即为源码;
> 2. 最高位如果是1，即为负数，对此补码再次计算补码，结果即为源码（即：**补码的补码即为源码**）。

### 为什么要有源码、反码、补码

反码、补码存在主要是为了是计算机运算更加方便。
具体可以参见http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html


## 运算符

根据参与运算的参数个数，可以分为下面几种：
> 1. 一元运算符：就是只需要一个参数的运算，比如++、--、~、！等；
> 2. 二元运算符：就是需要2个参数的运算，比如+、-、*、>、<等；
> 3. 三元运算符：就是需要3个参数的运算，比如?:运算符（isTrue ? A : B）。

### 位运算相关

> JAVA中的位运算符有下面几种：
> 
> 1. 左移（<<）、右移（>>）、无符号右移(>>>)
> 2. 位与(&)、位或(\|)\位非(~)、位异或(^)



#### 1. 位与

参加运算的两个数据，按二进制位进行位与运算.
> 例如：3&5
> 
> - 先将两个数据转化为二进制数,然后按位进行与运算，同为1结果为1，其它情况结果为0；
> - 即：11&101=001结果为1


特别提醒：***负数按补码形式参加按位与运算***。

位与运算的特殊用途：
> 1. 清零（将一个单元与0进行位与运算结果为零）
> 2. 取一个数中指定位（例如取X=1010 1101的低四位 则将X&00001111得到0000 1101）。



#### 2. 位或

参加运算的两个数据，按二进制位进行位或运算
> 例如：3 | 5
> 
> - 先将两个数据转化为二进制数，然后进行按位或运算，只要有一个是1结果为1，不然结果为0；
> - 即：11&101=111结果为7

特别提醒：***负数按补码形式参加按位或运算***。

位或运算的特殊用途：
> 常用来对数据的某些位置1（例如将X=1010 1010的第四位置1，则将X |0000 1111得到1010 1111）。


#### 3. 位非

> 快速计算结果的方法：
> 
> `~a`的值为-（a+1）。比如`~2=-3，~(-2)=1`

具体计算说明：
> 位非操作实际上是对计算机的**补码**进行操作的。 即：**先源码转补码，然后对补码进行逐位取反，最后再将处理后的补码转回源码**。
> 
> 1. 根据二进制源码获取其补码；
> 2. 对补码进行按位取反；
> 3. 将计算后的补码转换回源码。


对于**正整数，其补码与源码相同，对于负数，其补码位源码的取反再加一**。


#### 4. 位异或

参加运算的两个数据，按二进制位进行位异或运算

> 例如：3^5
> 
> - 先将两个数据转化为二进制数，然后进行按位异或运算，只要位不同结果为1，不然结果为0；
> - 即：11^101=110结果为6

异或运算的特殊用途：
> 1. 使特定位翻转找一个数，对应X要翻转的各位，该数的对应位为1，其余位为零，此数与X对应位异或即可。例：X=10101110，使X低4位翻转，用X ^0000 1111 = 1010 0001即可得到。
> 2. 与0异或得到原值

---

欢迎关注我的公众号“**架构笔录**”，原创技术文章第一时间推送，也可互动一起探讨交流技术。

![](https://raw.githubusercontent.com/veezean/pic_assets/master/assets/comm_pics/contact/gongzhonghao.png)
