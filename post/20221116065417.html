<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>JAVA缓存规范 —— 虽迟但到的JCache API与天生不俗的Spring Cache | Veezean的技术探秘馆</title><meta name="author" content="Veezean"><meta name="copyright" content="Veezean"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="业界各大厂商或开源团队都会构建并提供一些缓存框架组件提供给开发者按需选择，这里就会涉及到一个标准规范的遵循问题，本文我们一起聊聊JCache API规范与SpringCache规范。">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA缓存规范 —— 虽迟但到的JCache API与天生不俗的Spring Cache">
<meta property="og:url" content="http://blog.codingcoder.cn/post/20221116065417.html">
<meta property="og:site_name" content="Veezean的技术探秘馆">
<meta property="og:description" content="业界各大厂商或开源团队都会构建并提供一些缓存框架组件提供给开发者按需选择，这里就会涉及到一个标准规范的遵循问题，本文我们一起聊聊JCache API规范与SpringCache规范。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pics.codingcoder.cn/pics/202210050807355.png">
<meta property="article:published_time" content="2022-11-15T22:54:17.000Z">
<meta property="article:modified_time" content="2022-11-15T22:54:17.000Z">
<meta property="article:author" content="Veezean">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="缓存">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pics.codingcoder.cn/pics/202210050807355.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.codingcoder.cn/post/20221116065417.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":600,"position":"bottom","messagePrev":"此文章发布至今已经过去","messageNext":"天，鉴于技术更新迭代的速度估算，文中部分内容可能已过期，如有发现此类情况，请下方留言联系作者，一起探讨下。"},
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Veezean","link":"链接: ","source":"来源: Veezean的技术探秘馆","info":"著作权归作者所有，商业转载请联系作者获得授权，非商业转载请注明出处。欢迎关注公众号【架构悟道】，技术路上一起成长。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#a96899","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: false,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JAVA缓存规范 —— 虽迟但到的JCache API与天生不俗的Spring Cache',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-16 06:54:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3871042_lmkpqmsbbor.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202301281101915.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 专栏</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/msg-board/"><i class="fa-fw fas fa-book"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Veezean的技术探秘馆"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202301281101915.jpg"/><span class="site-name">Veezean的技术探秘馆</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 专栏</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/msg-board/"><i class="fa-fw fas fa-book"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JAVA缓存规范 —— 虽迟但到的JCache API与天生不俗的Spring Cache</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-15T22:54:17.000Z" title="发表于 2022-11-16 06:54:17">2022-11-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-15T22:54:17.000Z" title="更新于 2022-11-16 06:54:17">2022-11-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98%E8%AE%BE%E8%AE%A1/">缓存原理与实战设计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JAVA缓存规范 —— 虽迟但到的JCache API与天生不俗的Spring Cache"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/20221116065417.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/20221116065417.html" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>业界各大厂商或开源团队都会构建并提供一些缓存框架组件提供给开发者按需选择，这里就会涉及到一个标准规范的遵循问题，本文我们一起聊聊JCache API规范与SpringCache规范。</p>
</blockquote>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210050807355.png"></p>
<p>大家好，又见面了。</p>
<hr>
<blockquote>
<p>本文是笔者作为掘金技术社区签约作者的身份输出的缓存专栏系列内容，将会通过系列专题，讲清楚缓存的方方面面。如果感兴趣，欢迎关注以获取后续更新。</p>
</blockquote>
<hr>
<p>有诗云“纸上得来终觉浅，绝知此事要躬行”，在上一篇文章《<a target="_blank" rel="noopener" href="https://juejin.cn/post/7155278117479645221">手写本地缓存实战2—— 打造正规军，构建通用本地缓存框架</a>》中，我们一起论证并逐步实现了一套简化版本的通用本地缓存框架，并在过程中逐步剖析了缓存设计关键要素的实现策略。本篇文章中，我们一起来聊一聊缓存框架实现所需要遵循的规范。</p>
<h2 id="为何需要规范"><a href="#为何需要规范" class="headerlink" title="为何需要规范"></a>为何需要规范</h2><p>上一章中构建的最简化版本的缓存框架，虽然可以使用，但是也存在一个问题，就是它对外提供的实现接口都是框架根据自己的需要而自定义的。这样一来，项目集成了此缓存框架，后续如果想要更换缓存框架的时候，业务层面的改动会比较大。 —— 因为是自定义的框架接口，无法基于<code>里氏替换</code>原则来进行灵活的更换。</p>
<p>在业界各大厂商或者开源团队都会构建并提供一些自己实现的缓存框架或者组件，提供给开发者按需选择使用。如果大家都是各自<strong>闭门造车</strong>，势必导致业务中集成并使用某一缓存实现之后，想要更换缓存实现组件会难于登天。</p>
<p>千古一帝秦始皇统一天下后，颁布了<em>书同文、车同轨</em>等一系列法规制度，使得所有的车辆都遵循统一的轴距，然后都可以在官道上正常的通行，大大提升了流通性。而正所谓“国有国法、行有行规”，为了保证缓存框架的通用性、提升项目的可移植性，JAVA行业也迫切需要这么一个<strong>缓存规范</strong>，来约束各个缓存提供商给出的缓存框架都遵循相同的规范接口，业务中按照标准接口进行调用，无需与缓存框架进行深度耦合，使得缓存组件的更换成为一件简单点的事情。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210262122466.png"></p>
<p>在JAVA的缓存领域，流传比较广泛的主要是<code>JCache API</code>和<code>Spring Cache</code>两套规范，下面就一起来看下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202207102124124.gif"></p>
<h2 id="虽迟但到的JSR107-——-JCache-API"><a href="#虽迟但到的JSR107-——-JCache-API" class="headerlink" title="虽迟但到的JSR107 —— JCache API"></a>虽迟但到的JSR107 —— JCache API</h2><p>提到JAVA中的“行业规矩”，<code>JSR</code>是一个绕不开的话题。它的全称为<code>Java Specification Requests</code>，意思是<strong>JAVA规范提案</strong>。在该规范标准中，有公布过一个关于JAVA缓存体系的规范定义，也即<code>JSR 107</code>规范（<em>JCache API</em>），主要明确了JAVA中基于内存进行对象缓存构建的一些要求，涵盖内存对象的<em>创建</em>、<em>查询</em>、<em>更新</em>、<em>删除</em>、<em>一致性保证</em>等方面内容。</p>
<p><strong>JSR107</strong>规范早在<code>2012年</code>时草案就被提出，但却直到<code>2014年</code>才正式披露首个规范版本，也即<code>JCache API 1.0.0</code>版本，至此JAVA领域总算是有个正式的关于缓存的官方规范要求。</p>
<h3 id="揭秘JSR107-——-JCache-API内容探究"><a href="#揭秘JSR107-——-JCache-API内容探究" class="headerlink" title="揭秘JSR107 —— JCache API内容探究"></a>揭秘JSR107 —— JCache API内容探究</h3><p><strong>JSR107</strong>规范具体的要求形式，都以接口的形式封装在<code>javax.cache</code>包中进行提供。我们要实现的缓存框架需要遵循该规范，也就是需要引入<em>javax.cache</em>依赖包，并实现其中提供的相关接口即可。对于使用maven构建的项目中，可以在<code>pom.xml</code>中引入javax.cache依赖：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;javax.cache&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;cache-api&lt;&#x2F;artifactId&gt;
    &lt;version&gt;1.1.1&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p>在<code>JCache API</code>规范中，定义的缓存框架相关接口类之间的关系逻辑梳理如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210141512700.png"></p>
<p>我们要实现自己的本地缓存框架，也即需要实现上述各个接口。对上述各接口类的含义介绍说明如下：</p>
<table>
<thead>
<tr>
<th>接口类</th>
<th>功能定位描述</th>
</tr>
</thead>
<tbody><tr>
<td>CachingProvider</td>
<td><strong>SPI接口</strong>，缓存框架的加载入口。每个<code>Provider</code>中可以持有1个或者多个<code>CacheManager</code>对象，用来提供不同的缓存能力</td>
</tr>
<tr>
<td>CacheManager</td>
<td>缓存管理器接口，每个缓存管理器负责对具体的缓存容器的创建与管理，可以管理1个或者多个不同的<code>Cache</code>对象</td>
</tr>
<tr>
<td>Cache</td>
<td><code>Cache</code>缓存容器接口，负责存储具体的缓存数据，可以提供不同的容器能力</td>
</tr>
<tr>
<td>Entry</td>
<td><code>Cache</code>容器中存储的<code>key-value</code>键值对记录</td>
</tr>
</tbody></table>
<p>作为通用规范，这里将<code>CachingProvider</code>定义为了一个<strong>SPI接口</strong>（<code>Service Provider Interface</code>，服务提供接口），主要是借助JDK自带的服务提供发现能力，来实现按需加载各自实现的功能逻辑，有点<code>IOC</code>的意味。这样设计有一定的好处：</p>
<ul>
<li><strong>对于框架</strong>：</li>
</ul>
<p>需要遵循规范，提供上述接口的实现类。然后可以实现热插拔，与业务解耦。</p>
<ul>
<li><strong>对于业务</strong>：</li>
</ul>
<p>先指定需要使用的<code>SPI</code>的具体实现类，然后业务逻辑中便无需感知缓存具体的实现，直接基于<code>JCache API</code>通用接口进行使用即可。后续如果需要更换缓存实现框架，只需要切换下使用的<code>SPI</code>的具体实现类即可。</p>
<p>根据上述介绍，一个基于<strong>JCache API</strong>实现的缓存框架在实际项目中使用时的对象层级关系可能会是下面这种场景（假设使用<em>LRU策</em>略存储部门信息、使用<em>普通策略</em>存储用户信息）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210150833102.png"></p>
<p>那么如何去理解<code>JCache API</code>中几个接口类的关系呢？</p>
<p>几个简单的说明：</p>
<ol>
<li><p><strong>CachingProvider</strong>并无太多实际逻辑层面的功能，只是用来基于SPI机制，方便项目中集成插拔使用。内部持有CacheManager对象，实际的缓存管理能力，由CacheManager负责提供。</p>
</li>
<li><p><strong>CacheManager</strong>负责具体的缓存管理相关能力实现，实例由<code>CachingProvider</code>提供并持有，CachingProvider可以持有一个或者多个不同的<code>CacheManager</code>对象。这些CacheManager对象可以是相同类型，也可以是不同类型，比如我们可以实现2种缓存框架，一种是<code>基于内存</code>的缓存，一种是<code>基于磁盘</code>的缓存，则可以分别提供两种不同的<em>CacheManager</em>，供业务按需调用。</p>
</li>
<li><p><strong>Cache</strong>是CacheManager负责创建并管理的具体的缓存容器，也可以有一个或者多个，如业务中会涉及到为用户列表和部门列表分别创建独立的<code>Cache</code>存储。此外，Cache容器也可以根据需要提供不同的Cache容器类型，以满足不同场景对于缓存容器的不同诉求，如我们可以实现一个类似<code>HashMap</code>的普通键值对Cache容器，也可以提供一个基于<code>LRU</code>淘汰策略的Cache容器。</p>
</li>
</ol>
<p>至此呢，我们厘清了<strong>JCache API</strong>规范的大致内容。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202207102124124.gif"></p>
<h3 id="插叙-——-SPI何许人也"><a href="#插叙-——-SPI何许人也" class="headerlink" title="插叙 —— SPI何许人也"></a>插叙 —— SPI何许人也</h3><p>按照<code>JSR107</code>规范试编写缓存具体能力时，我们需要实现一个<strong>SPI接口</strong>的实现类，然后由JDK提供的加载能力将我们扩展的缓存服务加载到JVM中供使用。</p>
<p>提到<em>API</em>我们都耳熟能详，也就是我们常规而言的接口。但说起<strong>SPI</strong>也许很多小伙伴就有点陌生了。其实SPI也并非是什么新鲜玩意，它是<em>JDK内置</em>的一种服务的<strong>提供</strong>与<strong>发现</strong>、<strong>加载</strong>机制。按照JAVA的面向对象编码的思想，为了降低代码的耦合度、提升代码的灵活性，往往需要利用好<code>抽象</code>这一特性，比如一般会比较推荐基于接口进行编码、而尽量避免强依赖某个具体的功能实现类 —— 这样才能让构建出的系统具有更好的扩展性，更符合面向对象设计原则中的<code>里式替换</code>原则。SPI便是为了支持这一诉求而提供的能力，它允许将接口具体的实现类交由业务或者三方进行独立构建，然后加载到JVM中以供业务进行使用。</p>
<p>为了这一点，我们需要在<code>resource/META-INF/services</code>目录下新建一个文件，文件名即为SPI接口名称<code>javax.cache.spi.CachingProvider</code>，然后在文件内容中，写入我们要注入进入的我们自己的<strong>Provider</strong>实现类：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210150945611.png"></p>
<p>这样，我们就完成了将我们自己的<code>MyCachingProvider</code>功能注入到系统中。在业务使用时，可以通过<code>Caching.getCachingProvider()</code>获取到注入的自定义<strong>Provider</strong>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;
    CachingProvider provider &#x3D;  Caching.getCachingProvider();
    System.out.println(provider);
&#125;</code></pre>

<p>从输出的结果可以看出，获取到了自定义的Provider对象：</p>
<pre class="line-numbers language-none"><code class="language-none">com.veezean.skills.cache.fwk.MyCachingProvider@7adf9f5f</code></pre>

<p>获取到<code>Provider</code>之后，便可以进一步的获取到<code>Manager</code>对象，进而业务层面层面可以正常使用。</p>
<h3 id="JCache-API规范的实现"><a href="#JCache-API规范的实现" class="headerlink" title="JCache API规范的实现"></a>JCache API规范的实现</h3><p><strong>JSR</strong>作为JAVA领域正统行规，制定的时候往往考虑到各种可能的灵活性与通用性。作为JSR中根正苗红的<code>JCache API</code>规范，也沿袭了这一风格特色，框架接口的定义与实现也非常的丰富，几乎可以扩展自定义任何你需要的处理策略。 —— 但恰是这一点，也让其整个框架的接口定义过于<strong>重量级</strong>。对于缓存框架实现者而言，遵循<code>JCache API</code>需要实现众多的接口，需要做很多额外的实现处理。</p>
<p>比如，我们实现<code>CacheManager</code>的时候，需要实现如下这么多的接口：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MemCacheManager implements CacheManager &#123;
    private CachingProvider cachingProvider;
    private ConcurrentHashMap&lt;String, Cache&gt; caches;
    public MemCacheManager(CachingProvider cachingProvider, ConcurrentHashMap&lt;String, Cache&gt; caches) &#123;
        this.cachingProvider &#x3D; cachingProvider;
        this.caches &#x3D; caches;
    &#125;
    @Override
    public CachingProvider getCachingProvider() &#123;
    &#125;
    @Override
    public URI getURI() &#123;
    &#125;
    @Override
    public ClassLoader getClassLoader() &#123;
    &#125;
    @Override
    public Properties getProperties() &#123;
    &#125;
    @Override
    public &lt;K, V, C extends Configuration&lt;K, V&gt;&gt; Cache&lt;K, V&gt; createCache(String s, C c) throws IllegalArgumentException &#123;
    &#125;
    @Override
    public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String s, Class&lt;K&gt; aClass, Class&lt;V&gt; aClass1) &#123;
    &#125;
    @Override
    public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String s) &#123;
    &#125;
    @Override
    public Iterable&lt;String&gt; getCacheNames() &#123;
    &#125;
    @Override
    public void destroyCache(String s) &#123;
    &#125;
    @Override
    public void enableManagement(String s, boolean b) &#123;
    &#125;
    @Override
    public void enableStatistics(String s, boolean b) &#123;
    &#125;
    @Override
    public void close() &#123;
    &#125;
    @Override
    public boolean isClosed() &#123;
    &#125;
    @Override
    public &lt;T&gt; T unwrap(Class&lt;T&gt; aClass) &#123;
    &#125;
&#125;</code></pre>

<p>长长的一摞接口等着实现，看着都<strong>令人上头</strong>，作为缓存提供商，便需要按照自己的能力去实现这些接口，以保证相关缓存能力是按照规范对外提供。也正是因为JCache API这种不接地气的表现，让其虽是JAVA 领域的正统规范，却经常被<em>束之高阁</em>，沦落成为了一种名义规范。业界主流的本地缓存框架中，比较出名的当属<code>Ehcache</code>了（当然，<code>Spring4.1</code>中也增加了对JSR规范的支持）。此外，<strong>Redis</strong>的本地客户端<code>Redisson</code>也有实现全套JCache API规范，用户可以基于Redisson调用JCache API的标准接口来进行缓存数据的操作。</p>
<h3 id="JSR107提供的注解操作方法"><a href="#JSR107提供的注解操作方法" class="headerlink" title="JSR107提供的注解操作方法"></a>JSR107提供的注解操作方法</h3><p>前面提到了作为供应商想要实现<em>JSR107</em>规范的时候会比较复杂，需要做很多自己的处理逻辑。但是对于业务使用者而言，JSR107还是比较贴心的。比如JSR107中就将一些常用的API方法封装为<code>注解</code>，利用注解来大大简化编码的复杂度，降低缓存对于业务逻辑的<em>侵入性</em>，使得业务开发人员可以更加专注于业务本身的开发。</p>
<p><code>JSR107</code>规范中常用的一些缓存操作注解方法梳理如下面的表格：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>含义说明</th>
</tr>
</thead>
<tbody><tr>
<td>@CacheResult</td>
<td>将指定的<code>key</code>和<code>value</code>映射内容存入到缓存容器中</td>
</tr>
<tr>
<td>@CachePut</td>
<td>更新指定缓存容器中指定<code>key</code>值缓存记录内容</td>
</tr>
<tr>
<td>@CacheRemove</td>
<td>移除指定缓存容器中指定<code>key</code>值对应的缓存记录</td>
</tr>
<tr>
<td>@CacheRemoveAll</td>
<td>字面含义，移除指定缓存容器中的所有缓存记录</td>
</tr>
<tr>
<td>@CacheKey</td>
<td>作为接口参数前面修饰，用于指定特定的入参作为缓存<code>key</code>值的组成部分</td>
</tr>
<tr>
<td>@CacheValue</td>
<td>作为接口参数前面的修饰，用于指定特定的入参作为缓存<code>value</code>值</td>
</tr>
</tbody></table>
<p>上述注解主要是添加在方法上面，用于自动将方法的入参与返回结果之间进行一个映射与自动缓存，对于后续请求如果命中缓存则直接返回缓存结果而无需再次执行方法的具体处理，以此来提升接口的响应速度与承压能力。</p>
<p>比如下面的查询接口上，通过<code>@CacheResult</code>注解可以将查询请求与查询结果缓存起来进行使用：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@CacheResult(cacheName &#x3D; &quot;books&quot;)
public Book findBookByName(@CacheKey String bookName) &#123;
    return bookDao.queryByName(bookName);
&#125;</code></pre>

<p>当<strong>Book</strong>信息发生变更的时候，为了保证缓存数据的准确性，需要同步更新缓存内容。可以通过在更新方法上面添加<code>@CachePut</code>接口即可达成目的：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@CachePut(cacheName &#x3D; &quot;books&quot;)
public void updateBookInfo(@CacheKey String bookName, @CacheValue Book book) &#123;
    bookDao.updateBook(bookName, book);
&#125;</code></pre>

<p>这里分别适用了<code>@CacheKey</code>和<code>@CacheValue</code>指定了需要更新的缓存记录key值，以及需要将其更新为的新的value值。</p>
<p>同样地，借助注解<code>@CacheRemove</code>可以完成对应缓存记录的删除：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@CacheRemove(cacheName &#x3D; &quot;books&quot;)
public void deleteBookInfo(@CacheKey String bookName) &#123;
    bookDao.deleteBookByName(bookName)
&#125;</code></pre>

<h2 id="爱屋及乌-——-Spring框架制定的Cache规范"><a href="#爱屋及乌-——-Spring框架制定的Cache规范" class="headerlink" title="爱屋及乌 —— Spring框架制定的Cache规范"></a>爱屋及乌 —— Spring框架制定的Cache规范</h2><p>JSR 107（JCache API）规范的诞生可谓是一路坎坷，拖拖拉拉直到<strong>2014</strong>年才发布了首个<code>1.0.0</code>版本规范。但是在JAVA界风头无两的<strong>Spring</strong>框架早在<code>2011</code>年就已经在其3.1版本中提供了缓存抽象层的规范定义，并借助Spring的优秀设计与良好生态，迅速得到了各个软件开发团体的青睐，各大缓存厂商也陆续提供了符合<code>Spring Cache</code>规范的自家缓存产品。</p>
<p><strong>Spring Cache</strong>并非是一个具体的缓存实现，而是和JSR107类似的一套<em>缓存规范</em>，基于注解并可实现与Spring的各种高级特性无缝集成，受到了广泛的追捧。各大缓存提供商几乎都有基于Spring Cache规范进行实现的缓存组件。比如后面我们会专门介绍的<code>Guava Cache</code>、<code>Caffeine Cache</code>以及同样支持JSR107规范的<code>Ehcache</code>等等。</p>
<p>得力于Spring在JAVA领域无可撼动的地位，造就了<strong>Spring Cache</strong>已成为JAVA缓存领域的“事实标准”，深有“<em>功高盖主</em>”的味道。</p>
<h3 id="Spring-Cache使用不同缓存组件"><a href="#Spring-Cache使用不同缓存组件" class="headerlink" title="Spring Cache使用不同缓存组件"></a>Spring Cache使用不同缓存组件</h3><p>如果要基于<code>Spring Cache</code>规范来进行缓存的操作，首先在项目中需要引入此规范的定义：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-cache&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p>这样，在业务代码中，就可以使用Spring Cache规范中定义的一些注解方法。前面有提过，<em>Spring Cache只是一个规范声明</em>，可以理解为一堆接口定义，而并没有提供具体的接口功能实现。具体的功能实现，由业务根据实际选型需要，引入相应缓存组件的jar库文件依赖即可 —— 这一点是Spring框架中极其普遍的一种做法。</p>
<p>假如我们需要使用<code>Guava Cache</code>来作为我们实际缓存能力提供者，则我们只需要引入对应的依赖即可：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;
    &lt;version&gt;30.1.1-jre&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p>这样一来，我们便实现了使用Guava cache作为存储服务提供者、且基于Spring Cache接口规范进行缓存操作。Spring作为JAVA领域的一个相当优秀的框架，得益于其优秀的<strong>封装</strong>设计思想，使得更换缓存组件也显得非常容易。比如现在想要将上面的<em>Guava cache</em>更换为<code>Caffeine cache</code>作为新的缓存能力提供者，则业务代码中将依赖包改为Caffeine cache并简单的做一些细节配置即可：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;com.github.ben-manes.caffeine&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;caffeine&lt;&#x2F;artifactId&gt;
    &lt;version&gt;3.1.1&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p>这样一来，对于业务使用者而言，可以方便的进行缓存具体实现者的替换。而作为缓存能力提供商而言，自己可以轻易的被同类产品替换掉，所以也鞭策自己去提供更好更强大的产品，巩固自己的地位，也由此促进整个生态的<strong>良性演进</strong>。</p>
<h3 id="Spring-Cache规范提供的注解"><a href="#Spring-Cache规范提供的注解" class="headerlink" title="Spring Cache规范提供的注解"></a>Spring Cache规范提供的注解</h3><p>需要注意的是，使用Spring Cache缓存前，需要先手动开启对于缓存能力的支持，可以通过<code>@EnableCaching</code>注解来完成。</p>
<p>除了*@EnableCaching*，在Spring Cache中还定义了一些其它的常用注解方法，梳理归纳如下：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>含义说明</th>
</tr>
</thead>
<tbody><tr>
<td>@EnableCaching</td>
<td>开启使用缓存能力</td>
</tr>
<tr>
<td>@Cacheable</td>
<td>添加相关内容到缓存中</td>
</tr>
<tr>
<td>@CachePut</td>
<td>更新相关缓存记录</td>
</tr>
<tr>
<td>@CacheEvict</td>
<td>删除指定的缓存记录，如果需要清空指定容器的全部缓存记录，可以指定<code>allEntities=true</code>来实现</td>
</tr>
</tbody></table>
<p>具体的使用上，其实和JSR107规范中提供的注解用法相似。</p>
<p>当然了，JAVA领域缓存事实规范地位虽已奠定，但是Spring Cache依旧是保持着一个兼收并蓄的姿态，并积极的兼容了JCache API相关规范，比如<code>Spring4.1</code>起项目中可以使用JSR107规范提供的相关注解方法来操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210260726749.png"></p>
<h2 id="小结回顾"><a href="#小结回顾" class="headerlink" title="小结回顾"></a>小结回顾</h2><p>好啦，关于JAVA中的<strong>JSR107</strong>规范以及<strong>Spring Cache</strong>规范，以及各自典型代表，我们就聊到这里。</p>
<p>那么，关于本文中提及的缓存规范的内容，你是否有自己的一些想法与见解呢？欢迎评论区一起交流下，期待和各位小伙伴们一起切磋、共同成长。</p>
<p>📣 <strong>补充说明1</strong> ：</p>
<blockquote>
<p>本文属于《<a target="_blank" rel="noopener" href="https://juejin.cn/column/7140852038258147358">深入理解缓存原理与实战设计</a>》系列专栏的内容之一。该专栏围绕缓存这个宏大命题进行展开阐述，全方位、系统性地深度剖析各种缓存实现策略与原理、以及缓存的各种用法、各种问题应对策略，并一起探讨下缓存设计的哲学。</p>
<p>如果有兴趣，也欢迎关注此专栏。</p>
</blockquote>
<p>📣 <strong>补充说明2</strong> ：</p>
<ul>
<li>关于本文中涉及的<strong>演示代码</strong>的完整示例，我已经整理并提交到github中，如果您有需要，可以自取：<a target="_blank" rel="noopener" href="https://github.com/veezean/JavaBasicSkills">https://github.com/veezean/JavaBasicSkills</a></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202207102124124.gif"></p>
<p><strong>我是悟道，聊技术、又不仅仅聊技术~</strong></p>
<p>如果觉得有用，请<strong>点赞 + 关注</strong>让我感受到您的支持。也可以关注下我的公众号【架构悟道】，获取更及时的更新。</p>
<p>期待与你一起探讨，一起成长为更好的自己。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202207091312091.gif"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202207091317876.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://blog.codingcoder.cn">Veezean</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.codingcoder.cn/post/20221116065417.html">http://blog.codingcoder.cn/post/20221116065417.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.codingcoder.cn" target="_blank">Veezean的技术探秘馆</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E7%BC%93%E5%AD%98/">缓存</a></div><div class="post_share"><div class="social-share" data-image="https://pics.codingcoder.cn/pics/202210050807355.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wexin_zanshangma.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wexin_zanshangma.png" alt="码字不易，感谢鼓励"/></a><div class="post-qr-code-desc">码字不易，感谢鼓励</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/20221123080317.html" title="重新认识下JVM级别的本地缓存框架Guava Cache——优秀从何而来"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210050807355.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">重新认识下JVM级别的本地缓存框架Guava Cache——优秀从何而来</div></div></a></div><div class="next-post pull-right"><a href="/post/20221107115817.html" title="手写本地缓存实战1——各个击破，按需应对实际使用场景"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210050807355.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">手写本地缓存实战1——各个击破，按需应对实际使用场景</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/20221028085417.html" title="聊一聊作为高并发系统基石之一的缓存，会用很简单，用好才是技术活"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210050807355.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-28</div><div class="title">聊一聊作为高并发系统基石之一的缓存，会用很简单，用好才是技术活</div></div></a></div><div><a href="/post/20221102081617.html" title="聊一聊安全且正确使用缓存的那些事 —— 关于缓存可靠性、关乎数据一致性"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210050807355.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-02</div><div class="title">聊一聊安全且正确使用缓存的那些事 —— 关于缓存可靠性、关乎数据一致性</div></div></a></div><div><a href="/post/20221107085417.html" title="手写本地缓存实战2—— 打造正规军，构建通用本地缓存框架"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210050807355.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-07</div><div class="title">手写本地缓存实战2—— 打造正规军，构建通用本地缓存框架</div></div></a></div><div><a href="/post/20221107115817.html" title="手写本地缓存实战1——各个击破，按需应对实际使用场景"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210050807355.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-07</div><div class="title">手写本地缓存实战1——各个击破，按需应对实际使用场景</div></div></a></div><div><a href="/post/20221123080317.html" title="重新认识下JVM级别的本地缓存框架Guava Cache——优秀从何而来"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210050807355.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-23</div><div class="title">重新认识下JVM级别的本地缓存框架Guava Cache——优秀从何而来</div></div></a></div><div><a href="/post/20221125071617.html" title="重新认识下JVM级别的本地缓存框架Guava Cache(2)——深入解读其容量限制与数据淘汰策略"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210050807355.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="title">重新认识下JVM级别的本地缓存框架Guava Cache(2)——深入解读其容量限制与数据淘汰策略</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202301281101915.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Veezean</div><div class="author-info__description">这个是作者介绍</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" href="/about/"><i class="fab fa-github"></i><span>联系我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/contact/" target="_blank" title="微信公众号"><i class="iconfont icon-weixingongzhonghao"></i></a><a class="social-icon" href="/contact/" target="_blank" title="微信"><i class="iconfont icon-weixin"></i></a><a class="social-icon" href="https://juejin.cn/user/1028798616709294/posts" target="_blank" title="掘金技术社区"><i class="iconfont icon-juejin"></i></a><a class="social-icon" href="https://www.cnblogs.com/softwarearch" target="_blank" title="博客园"><i class="iconfont icon-cnblogs"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E8%A7%84%E8%8C%83"><span class="toc-number">1.</span> <span class="toc-text">为何需要规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%BD%E8%BF%9F%E4%BD%86%E5%88%B0%E7%9A%84JSR107-%E2%80%94%E2%80%94-JCache-API"><span class="toc-number">2.</span> <span class="toc-text">虽迟但到的JSR107 —— JCache API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%AD%E7%A7%98JSR107-%E2%80%94%E2%80%94-JCache-API%E5%86%85%E5%AE%B9%E6%8E%A2%E7%A9%B6"><span class="toc-number">2.1.</span> <span class="toc-text">揭秘JSR107 —— JCache API内容探究</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%8F%99-%E2%80%94%E2%80%94-SPI%E4%BD%95%E8%AE%B8%E4%BA%BA%E4%B9%9F"><span class="toc-number">2.2.</span> <span class="toc-text">插叙 —— SPI何许人也</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JCache-API%E8%A7%84%E8%8C%83%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">JCache API规范的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSR107%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">JSR107提供的注解操作方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B1%E5%B1%8B%E5%8F%8A%E4%B9%8C-%E2%80%94%E2%80%94-Spring%E6%A1%86%E6%9E%B6%E5%88%B6%E5%AE%9A%E7%9A%84Cache%E8%A7%84%E8%8C%83"><span class="toc-number">3.</span> <span class="toc-text">爱屋及乌 —— Spring框架制定的Cache规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Cache%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">Spring Cache使用不同缓存组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Cache%E8%A7%84%E8%8C%83%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">Spring Cache规范提供的注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%9B%9E%E9%A1%BE"><span class="toc-number">4.</span> <span class="toc-text">小结回顾</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/20230118065917.html" title="探讨下如何更好的使用缓存 —— Redis缓存的特殊用法以及与本地缓存一起构建多级缓存的实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210050807355.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="探讨下如何更好的使用缓存 —— Redis缓存的特殊用法以及与本地缓存一起构建多级缓存的实现"/></a><div class="content"><a class="title" href="/post/20230118065917.html" title="探讨下如何更好的使用缓存 —— Redis缓存的特殊用法以及与本地缓存一起构建多级缓存的实现">探讨下如何更好的使用缓存 —— Redis缓存的特殊用法以及与本地缓存一起构建多级缓存的实现</a><time datetime="2023-01-17T22:59:17.000Z" title="发表于 2023-01-18 06:59:17">2023-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/20230113071317.html" title="面对集中式缓存实现上的挑战，Redis交出的是何种答卷？聊聊Redis的主从、哨兵与集群部署模式"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210050807355.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面对集中式缓存实现上的挑战，Redis交出的是何种答卷？聊聊Redis的主从、哨兵与集群部署模式"/></a><div class="content"><a class="title" href="/post/20230113071317.html" title="面对集中式缓存实现上的挑战，Redis交出的是何种答卷？聊聊Redis的主从、哨兵与集群部署模式">面对集中式缓存实现上的挑战，Redis交出的是何种答卷？聊聊Redis的主从、哨兵与集群部署模式</a><time datetime="2023-01-12T23:13:17.000Z" title="发表于 2023-01-13 07:13:17">2023-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/20230112090217.html" title="Redis缓存何以一枝独秀？(2) —— 聊聊Redis的数据过期、数据淘汰以及数据持久化的实现机制"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210050807355.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis缓存何以一枝独秀？(2) —— 聊聊Redis的数据过期、数据淘汰以及数据持久化的实现机制"/></a><div class="content"><a class="title" href="/post/20230112090217.html" title="Redis缓存何以一枝独秀？(2) —— 聊聊Redis的数据过期、数据淘汰以及数据持久化的实现机制">Redis缓存何以一枝独秀？(2) —— 聊聊Redis的数据过期、数据淘汰以及数据持久化的实现机制</a><time datetime="2023-01-12T01:02:17.000Z" title="发表于 2023-01-12 09:02:17">2023-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/20230110072917.html" title="Redis缓存何以一枝独秀？——从百变应用场景与热门面试题中感受下Redis的核心特性与使用注意点"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210050807355.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis缓存何以一枝独秀？——从百变应用场景与热门面试题中感受下Redis的核心特性与使用注意点"/></a><div class="content"><a class="title" href="/post/20230110072917.html" title="Redis缓存何以一枝独秀？——从百变应用场景与热门面试题中感受下Redis的核心特性与使用注意点">Redis缓存何以一枝独秀？——从百变应用场景与热门面试题中感受下Redis的核心特性与使用注意点</a><time datetime="2023-01-09T23:29:17.000Z" title="发表于 2023-01-10 07:29:17">2023-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/20230107070417.html" title="JAVA中使用最广泛的本地缓存？Ehcache的自信从何而来3 —— 本地缓存变身分布式集群缓存，打破本地缓存天花板"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pics.codingcoder.cn/pics/202210050807355.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JAVA中使用最广泛的本地缓存？Ehcache的自信从何而来3 —— 本地缓存变身分布式集群缓存，打破本地缓存天花板"/></a><div class="content"><a class="title" href="/post/20230107070417.html" title="JAVA中使用最广泛的本地缓存？Ehcache的自信从何而来3 —— 本地缓存变身分布式集群缓存，打破本地缓存天花板">JAVA中使用最广泛的本地缓存？Ehcache的自信从何而来3 —— 本地缓存变身分布式集群缓存，打破本地缓存天花板</a><time datetime="2023-01-06T23:04:17.000Z" title="发表于 2023-01-07 07:04:17">2023-01-07</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2023 By Veezean</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn"><span>备案信息： 苏ICP备20019163号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'gmAHZQPv9N5AdyJg7sXVJAYg-gzGzoHsz',
      appKey: 'qW16efVsSUyMnjDbGeXgxjLv',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>